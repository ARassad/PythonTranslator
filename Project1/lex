%{
#include "python.bison_tab.h"
#include "tree_struct.h"
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include "printTree.h"
extern int yyparse(void);
void calcIndentation(int* indentStack, int* indexTop, int len, struct DedentStruct* dedents);
struct DedentStruct
{
	int DedentType;
	int count;
};
struct DedentStruct dedents;
int firstEOF = 1;
int secondEOF = 1;
int indexTop = 0;
int indentStack[1000];
%}
%option noyywrap
%option never-interactive
%option yylineno
%x ONECOMMENT
%x STRING_0
%x DOUBLELONGSTRING
%x LONGSTRING
%x STRINGS
%x DEDENT0
%x DEDENT_OUTPUT

INT 		[0-9]+
NUMEXP		(e|E)(\-|\+)?{INT}
FLOAT		([0-9]*([0-9]\.|\.[0-9])[0-9]*({NUMEXP})?|{INT}({NUMEXP}))
IDENTIFIER 	[A-Za-z_][A-Za-z0-9_]*

%%

%{
	char comment[1000];
	comment[0] = 0;
	char hex[3];
	int parenthesesOpenCount = 0;
	int squarebracketsOpenCount = 0;
	int curlybracesOpenCount = 0;
	int isLogicalString = 0;
	

%}

<DEDENT_OUTPUT>""/. {	
						if (dedents.count > 0){
							printf("DENT %d\n", dedents.DedentType);
							dedents.count--;
							return dedents.DedentType;
						}
						else	
							BEGIN(INITIAL);
				}

^\s*\n			{;}

#	{BEGIN(ONECOMMENT);}
<ONECOMMENT>[^\\\n]+ {;}
<ONECOMMENT>[\\\n]	{ BEGIN(INITIAL);}


\"\"\"													{BEGIN(DOUBLELONGSTRING); comment[0] = 0;}
<DOUBLELONGSTRING>\\n											strcat(comment,"\n");
<DOUBLELONGSTRING,STRING_0,LONGSTRING>\\\"						strcat(comment,"\"");
<DOUBLELONGSTRING,LONGSTRING,STRING_0,STRINGS>\\\\				strcat(comment,"\\");
<DOUBLELONGSTRING,LONGSTRING,STRING_0,STRINGS>\\\'				strcat(comment,"\'");
<DOUBLELONGSTRING,STRING_0,LONGSTRING>\'							strcat(comment,"\'");
<DOUBLELONGSTRING,STRINGS,LONGSTRING>\"							strcat(comment,"\"");
<DOUBLELONGSTRING,LONGSTRING,STRING_0,STRINGS>\\newline
<DOUBLELONGSTRING,LONGSTRING,STRING_0,STRINGS>\\a					strcat(comment,"\a");
<DOUBLELONGSTRING,LONGSTRING,STRING_0,STRINGS>\\b					strcat(comment,"\b");
<DOUBLELONGSTRING,LONGSTRING,STRING_0,STRINGS>\\f					strcat(comment,"\f");
<DOUBLELONGSTRING,LONGSTRING,STRING_0,STRINGS>\\r					strcat(comment,"\r");
<DOUBLELONGSTRING,LONGSTRING,STRING_0,STRINGS>\\t					strcat(comment,"\t");
<DOUBLELONGSTRING,LONGSTRING,STRING_0,STRINGS>\\v					strcat(comment,"\v");
<DOUBLELONGSTRING,LONGSTRING,STRING_0,STRINGS>\\x([0-9a-fA-F]){2}	{
																	hex[0] = strtol(yytext + 2,0,16);
																	hex[1] = 0;
																	strcat(comment,hex);
																}
<DOUBLELONGSTRING,LONGSTRING,STRING_0,STRINGS>[^\"\\\n\'\a\b\f\r\t\v\x]+		strcat(comment,yytext);
<DOUBLELONGSTRING>\"\"\" 		{
									yylval.string_value=(char *)malloc(strlen(comment)+1);
									yylval.string_value[0] = 0;
									strcat(yylval.string_value, comment); 
									BEGIN(INITIAL);
									return STRING;
								}

\'{3}									{BEGIN(LONGSTRING); comment[0] = 0;}
<LONGSTRING>\\n							strcat(comment,"\n");
<LONGSTRING,STRINGS>\\\'				strcat(comment,"\'");
<LONGSTRING>\'\'\' 						{
											yylval.string_value=(char *)malloc(strlen(comment)+1);
											yylval.string_value[0] = 0;
											strcat(yylval.string_value, comment);
											BEGIN(INITIAL);
											return STRING;
										}

<DEDENT0>^[ \t]*#		{BEGIN(ONECOMMENT);}
<DEDENT0>^[ \t]*\n		{;}
<DEDENT0>^[ ]+  {
				if( !(isLogicalString || parenthesesOpenCount || squarebracketsOpenCount || curlybracesOpenCount))
				{
					calcIndentation(indentStack, &indexTop, strlen(yytext), &dedents);
					BEGIN(DEDENT_OUTPUT);
				}
			}
<DEDENT0>^[\t]+		{
				if( !(isLogicalString || parenthesesOpenCount || squarebracketsOpenCount || curlybracesOpenCount))
				{
					calcIndentation(indentStack, &indexTop, strlen(yytext)*4, &dedents);
					BEGIN(DEDENT_OUTPUT);
				}
			}
<DEDENT0>^[ \t]{2,}	{
				if( !(isLogicalString || parenthesesOpenCount || squarebracketsOpenCount || curlybracesOpenCount))
				{
					printf("Error mixing tab and spacers on line %d\n", yylineno);
				}
			}
<DEDENT0>""/. {
				if( !(isLogicalString || parenthesesOpenCount || squarebracketsOpenCount || curlybracesOpenCount))
				{
					calcIndentation(indentStack, &indexTop, 0, &dedents);
					BEGIN(DEDENT_OUTPUT);
				}
			}

\"						{BEGIN(STRING_0);comment[0] = 0;}
<STRING_0,STRINGS>\n		{printf("Error in string %d - String literal not closed",yylineno);BEGIN(INITIAL);}
<STRING_0>\" 			{
							yylval.string_value=(char *)malloc(strlen(comment)+1);
							yylval.string_value[0] = 0;
							strcat(yylval.string_value, comment);
							BEGIN(INITIAL);
							return STRING;
						}

\'					{BEGIN(STRINGS);comment[0] = 0;}
<STRINGS>\' 		{
						yylval.string_value=(char *)malloc(strlen(comment)+1);
						yylval.string_value[0] = 0;
						strcat(yylval.string_value, comment);
						BEGIN(INITIAL);
						return STRING;
					}


False    	{ return FALSE; }
if     	 	{ return IF; }
import     	{ return IMPORT; }
from     	{ return FROM; }
in     		{ return IN; }
is     		{ return IS; }
as     		{ return AS; }
lambda     	{ return LAMBDA; }
not     	{ return NOT; }
or     		{ return OR; }
pass     	{ return PASS; }
raise     	{ return RAISE; }
return     	{ return RETURN; }
try     	{ return TRY; }
while     	{ return WHILE; }
for     	{ return FOR; }
with     	{ return WITH; }
None     	{ return NONE; }
True     	{ return TRUE; }
and     	{ return AND; }
assert     	{ return ASSERT; }
break     	{ return BREAK; }
class     	{ return CLASS; }
continue    { return CONTINUE; }
def     	{ return DEF; }
elif     	{ return ELIF; }
else     	{ return ELSE; }
except     	{ return EXCEPT; }
finally     { return FINALLY; }
yield		{ return YIELD; }
\+    		{ return '+'; }
-     		{ return '-'; }
\*     		{ return '*'; }
\*\*     	{ return POW; }
\/     		{ return '/'; }
\/\/     	{ return FLOOR_DIV; }
\%    		{ return '%'; }
@     		{ return '@'; }
\<\<     	{ return LEFT_SHIFT; }
>>     		{ return RIGHT_SHIFT; }
&   		{ return '&'; }
\|     		{ return '|'; }
\^    		{ return '^'; }
~     		{ return '~'; }
>     		{ return '>'; }
\<     		{ return '<'; }
\<=     	{ return LESSER_EQUAL; }
\>=     	{ return GREATER_EQUAL; }
==    		{ return EQUAL; }
!=     		{ return NOT_EQUAL; }
\(     		{ parenthesesOpenCount++; return '('; }
\)     		{ parenthesesOpenCount--; return ')'; }
\[     		{ squarebracketsOpenCount++; return '['; }
\]     		{ squarebracketsOpenCount--; return ']'; }
\{    		{ curlybracesOpenCount++; return '{'; }
\}     		{ curlybracesOpenCount--; return '}'; }
,     		{ return ','; }
:     		{ return ':'; }
\.     		{ return '.'; }
\;     		{ return ';'; }
\=    		{ return '='; }
->     		{ return ARROW; }
\+=     	{ return PLUS_ASSIGN; }
-=     		{ return MINUS_ASSIGN; }
\*=     	{ return MULT_ASSIGN; }
\/=     	{ return DIV_ASSIGN; }
\/\/=    	{ return -1; }
%=     		{ return MOD_ASSIGN; }
@=     		{ return -1; }
\&=     	{ return -1; }
\|=     	{ return -1; }
\^=     	{ return -1; }
>>=     	{ return -1; }
\<\<=   	{ return -1; }
\*\*=     	{ return POW_ASSIGN; }

{FLOAT}			{ yylval.float_value = atof(yytext); return FLOAT; }
{INT} 			{ yylval.int_value = atoi(yytext); return INT; }
{IDENTIFIER}	{ yylval.string_value=(char *)malloc(strlen(yytext)+1); strcpy(yylval.string_value, yytext); return ID; }

\\\s*\n		{printf("BACKSLASH\n"); isLogicalString = 1;}
\n 			{
				if( parenthesesOpenCount == 0 && squarebracketsOpenCount == 0 && curlybracesOpenCount == 0)
				{
					isLogicalString = 0;
					BEGIN(DEDENT0);
					return NEWLINE;
				}
			}
			
[ \t]		{;}

<<EOF>> {
			
			calcIndentation(indentStack, &indexTop, 0, &dedents);
			if (firstEOF == 0){
				
				if (dedents.count > 0) {
					printf("DENT FINISH %d\n", dedents.DedentType);
					dedents.count--;
					return dedents.DedentType;
				}
				else if (secondEOF == 1) {
					secondEOF = 0;
					yyterminate();
				}				
			}
			else {
				firstEOF = 0;
				return NEWLINE;
			}
		}
%%

void calcIndentation(int* indentStack, int* indexTop, int len, struct DedentStruct* dedents)
{
	if( len > indentStack[*indexTop] )
	{
		(*indexTop)++;
		indentStack[*indexTop] = len;
		(*dedents).count = 1;
		(*dedents).DedentType = INDENT;
	}
	else if( len < indentStack[*indexTop])
	{
		int dedentCount = *indexTop;
		while(len < indentStack[dedentCount])
			dedentCount--;
			
		if (len != indentStack[dedentCount])
			printf("Error: inconsistent dedent %d\n", len);
		else
		{
			(*dedents).count = 0;
			(*dedents).DedentType = DEDENT;
			while(*indexTop > dedentCount)
			{
				(*dedents).count += 1;
				(*indexTop)--;
			}
		}
	}		
}

int main(int argc, char *argv[])
{
	yyin = fopen(argv[1], "r");
	yyparse();
	freopen("resultGraph.txt","w",stdout);
	printTree();
	_execlpe("cmd", "/c", "graph.bat", "", 0,0,0);
	return 0;
}
