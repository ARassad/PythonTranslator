%{
#include <stdio.h>
#include <stdlib.h>
void calcIndentation(int* indentStack, int* indexTop, int len);
%}
%option noyywrap
%option never-interactive
%option yylineno
%x ONECOMMENT
%x STRING
%x DOUBLELONGSTRING
%x LONGSTRING
%x HEXDECIMAL
%x HEXDECIMALC
%x HEXDECIMALCC
%x HEXDECIMALCCC
%x STRINGS
%x DEDENT0

INT 		[0-9]+
NUMEXP		(e|E)(\-|\+)?{INT}
FLOAT		([0-9]*([0-9]\.|\.[0-9])[0-9]*({NUMEXP})?|{INT}({NUMEXP}))
IDENTIFIER 	[A-Za-z_][A-Za-z0-9_]*

%%

%{
	int indexTop = 0;
	int indentStack[1000];
	indentStack[0] = 0;
	char comment[1000];
	comment[0] = 0;
	char hex[3];
	int parenthesesOpenCount = 0;
	int squarebracketsOpenCount = 0;
	int curlybracesOpenCount = 0;
	int isLogicalString = 0;
%}

^\s*\n			printf("EMPTYSTRING\n");

#	{BEGIN(ONECOMMENT); comment[0] = 0;}
<ONECOMMENT>[^\\\n]+ strcat(comment, yytext);
<ONECOMMENT>[\\\n]	{printf("COMMENT : %s\n",comment); BEGIN(INITIAL);}


\"\"\"													{BEGIN(DOUBLELONGSTRING); comment[0] = 0;}
<DOUBLELONGSTRING>\\n											strcat(comment,"\n");
<DOUBLELONGSTRING,STRING,LONGSTRING>\\\"						strcat(comment,"\"");
<DOUBLELONGSTRING,LONGSTRING,STRING,STRINGS>\\\\				strcat(comment,"\\");
<DOUBLELONGSTRING,LONGSTRING,STRING,STRINGS>\\\'				strcat(comment,"\'");
<DOUBLELONGSTRING,STRING,LONGSTRING>\'							strcat(comment,"\'");
<DOUBLELONGSTRING,STRINGS,LONGSTRING>\"							strcat(comment,"\"");
<DOUBLELONGSTRING,LONGSTRING,STRING,STRINGS>\\newline
<DOUBLELONGSTRING,LONGSTRING,STRING,STRINGS>\\a					strcat(comment,"\a");
<DOUBLELONGSTRING,LONGSTRING,STRING,STRINGS>\\b					strcat(comment,"\b");
<DOUBLELONGSTRING,LONGSTRING,STRING,STRINGS>\\f					strcat(comment,"\f");
<DOUBLELONGSTRING,LONGSTRING,STRING,STRINGS>\\r					strcat(comment,"\r");
<DOUBLELONGSTRING,LONGSTRING,STRING,STRINGS>\\t					strcat(comment,"\t");
<DOUBLELONGSTRING,LONGSTRING,STRING,STRINGS>\\v					strcat(comment,"\v");
<DOUBLELONGSTRING,LONGSTRING,STRING,STRINGS>\\x([0-9a-fA-F]){2}	{
																	hex[0] = strtol(yytext + 2,0,16);
																	hex[1] = 0;
																	strcat(comment,hex);
																}
<DOUBLELONGSTRING,LONGSTRING,STRING,STRINGS>[^\"\\\n\'\a\b\f\r\t\v\x]+		strcat(comment,yytext);
<DOUBLELONGSTRING>\"\"\" 		{printf("LONGSTRING literal: %s\n",comment); BEGIN(INITIAL);}

\'{3}									{BEGIN(LONGSTRING); comment[0] = 0;}
<LONGSTRING>\\n							strcat(comment,"\n");
<LONGSTRING,STRINGS>\\\'				strcat(comment,"\'");
<LONGSTRING>\'\'\' 						{printf("LONGSTRING literal: %s\n",comment); BEGIN(INITIAL);}

<DEDENT0>^[ \t]*#		{comment[0] = 0; BEGIN(ONECOMMENT);}
<DEDENT0>^[ \t]*\n			printf("EMPTYSTRING\n");
<DEDENT0>^[ ]+  {
				if( !(isLogicalString || parenthesesOpenCount || squarebracketsOpenCount || curlybracesOpenCount))
				{
					calcIndentation(indentStack, &indexTop, strlen(yytext));
					BEGIN(INITIAL);
				}
			}
<DEDENT0>^[\t]+		{
				if( !(isLogicalString || parenthesesOpenCount || squarebracketsOpenCount || curlybracesOpenCount))
				{
					calcIndentation(indentStack, &indexTop, strlen(yytext)*4);
					BEGIN(INITIAL);
				}
			}
<DEDENT0>^[ \t]{2,}	{
				if( !(isLogicalString || parenthesesOpenCount || squarebracketsOpenCount || curlybracesOpenCount))
				{
					printf("Error mixing tab and spacers on line %d\n", yylineno);
				}
			}
<DEDENT0>""/. {
				if( !(isLogicalString || parenthesesOpenCount || squarebracketsOpenCount || curlybracesOpenCount))
				{
					calcIndentation(indentStack, &indexTop, 0);
					BEGIN(INITIAL);
				}
			}

\"						{BEGIN(STRING);comment[0] = 0;}
<STRING,STRINGS>\n		{printf("Error in string %d - String literal not closed",yylineno);BEGIN(INITIAL);}
<STRING>\" 				{printf("String literal %s\n",comment); BEGIN(INITIAL);}

\'					{BEGIN(STRINGS);comment[0] = 0;}
<STRINGS>\' 		{printf("String literal %s\n",comment); BEGIN(INITIAL);}


False    	printf("Keyword(%s)\n", yytext);
if     	 	printf("Keyword(%s)\n", yytext);
import     	printf("Keyword(%s)\n", yytext);
from     	printf("Keyword(%s)\n", yytext);
in     		printf("Keyword(%s)\n", yytext);
is     		printf("Keyword(%s)\n", yytext);
as     		printf("Keyword(%s)\n", yytext);
lambda     	printf("Keyword(%s)\n", yytext);
not     	printf("Keyword(%s)\n", yytext);
or     		printf("Keyword(%s)\n", yytext);
pass     	printf("Keyword(%s)\n", yytext);
raise     	printf("Keyword(%s)\n", yytext);
return     	printf("Keyword(%s)\n", yytext);
try     	printf("Keyword(%s)\n", yytext);
while     	printf("Keyword(%s)\n", yytext);
with     	printf("Keyword(%s)\n", yytext);
None     	printf("Keyword(%s)\n", yytext);
True     	printf("Keyword(%s)\n", yytext);
and     	printf("Keyword(%s)\n", yytext);
assert     	printf("Keyword(%s)\n", yytext);
break     	printf("Keyword(%s)\n", yytext);
class     	printf("Keyword(%s)\n", yytext);
continue    printf("Keyword(%s)\n", yytext);
def     	printf("Keyword(%s)\n", yytext);
elif     	printf("Keyword(%s)\n", yytext);
else     	printf("Keyword(%s)\n", yytext);
except     	printf("Keyword(%s)\n", yytext);
finally     printf("Keyword(%s)\n", yytext);
yield		printf("Keyword(%s)\n", yytext);
\+    		printf("Operator(%s)\n", yytext);
-     		printf("Operator(%s)\n", yytext);
\*     		printf("Operator(%s)\n", yytext);
\*\*     	printf("Operator(%s)\n", yytext);
\/     		printf("Operator(%s)\n", yytext);
\/\/     	printf("Operator(%s)\n", yytext);
\%    		printf("Operator(%s)\n", yytext);
@     		printf("Operator(%s)\n", yytext);
\<\<     	printf("Operator(%s)\n", yytext);
>>     		printf("Operator(%s)\n", yytext);
&   		printf("Operator(%s)\n", yytext);
\|     		printf("Operator(%s)\n", yytext);
\^    		printf("Operator(%s)\n", yytext);
~     		printf("Operator(%s)\n", yytext);
>     		printf("Operator(%s)\n", yytext);
\<     		printf("Operator(%s)\n", yytext);
\<=     	printf("Operator(%s)\n", yytext);
\>=     	printf("Operator(%s)\n", yytext);
==    		printf("Operator(%s)\n", yytext);
!=     		printf("Operator(%s)\n", yytext);
\(     		{printf("Operator(%s)\n", yytext); parenthesesOpenCount++;}
\)     		{printf("Operator(%s)\n", yytext); parenthesesOpenCount--;}
\[     		{printf("Operator(%s)\n", yytext); squarebracketsOpenCount++;}
\]     		{printf("Operator(%s)\n", yytext); squarebracketsOpenCount--;}
\{    		{printf("Operator(%s)\n", yytext); curlybracesOpenCount++;}
\}     		{printf("Operator(%s)\n", yytext); curlybracesOpenCount--;}
,     		printf("Operator(%s)\n", yytext);
:     		printf("Operator(%s)\n", yytext);
\.     		printf("Operator(%s)\n", yytext);
\;     		printf("Operator(%s)\n", yytext);
\=    		printf("Operator(%s)\n", yytext);
->     		printf("Operator(%s)\n", yytext);
\+=     	printf("Operator(%s)\n", yytext);
-=     		printf("Operator(%s)\n", yytext);
\*=     	printf("Operator(%s)\n", yytext);
\/=     	printf("Operator(%s)\n", yytext);
\/\/=    	printf("Operator(%s)\n", yytext);
%=     		printf("Operator(%s)\n", yytext);
@=     		printf("Operator(%s)\n", yytext);
\&=     	printf("Operator(%s)\n", yytext);
\|=     	printf("Operator(%s)\n", yytext);
\^=     	printf("Operator(%s)\n", yytext);
>>=     	printf("Operator(%s)\n", yytext);
\<\<=   	printf("Operator(%s)\n", yytext);
\*\*=     	printf("Operator(%s)\n", yytext);

{FLOAT}			printf("Float(%f)\n", atof(yytext));
{INT} 			printf("Number(%d)\n", atoi(yytext));
{IDENTIFIER}	printf("Identifier(%s)\n", yytext);

\\\s*\n		{printf("BACKSLASH CONCATINATE FISICAL STRINGS TO LOGICAL STRING\n"); isLogicalString = 1;}
\n 			{
				if( parenthesesOpenCount == 0 && squarebracketsOpenCount == 0 && curlybracesOpenCount == 0)
				{
					printf("NEWLINE\n");
					isLogicalString = 0;
					BEGIN(DEDENT0);
				}
			}
			
[ \t]		{;}

<<EOF>> {calcIndentation(indentStack, &indexTop, 0); yyterminate();}
%%

void calcIndentation(int* indentStack, int* indexTop, int len)
{
	if( len > indentStack[*indexTop] )
	{
		(*indexTop)++;
		indentStack[*indexTop] = len;
		printf("INDENT(%d->%d)\n", indentStack[(*indexTop)-1], indentStack[(*indexTop)]);
	}
	else if( len < indentStack[*indexTop])
	{
		int dedentCount = *indexTop;
		while(len < indentStack[dedentCount])
			dedentCount--;
			
		if (len != indentStack[dedentCount])
			printf("Error: inconsistent dedent %d\n", len);
		else
		{
			while(*indexTop > dedentCount)
			{
				printf("DEDENT(%d->%d)\n", indentStack[*indexTop], indentStack[(*indexTop)-1]);
				(*indexTop)--;
			}
		}
	}		
}

int main(int argc, char *argv[])
{
	yyin = fopen(argv[1], "r");
	yylex();
	return 0;
}